class ByteStream {
  constructor(data){
  	this.data = data;
  	this.pos = 0;
  }

  // read the next byte off the stream
  readByte() {
  	return this.data[this.pos++];
  };

  // look at the next byte in the stream without updating the stream position
  peekByte() {
  	return this.data[this.pos];
  };

  // read an array of bytes
  readBytes(n) {
  	var bytes = new Array(n);
  	for(var i=0; i<n; i++){
  		bytes[i] = this.readByte();
  	}
  	return bytes;
  };

  // peek at an array of bytes without updating the stream position
  peekBytes(n) {
  	var bytes = new Array(n);
  	for(var i=0; i<n; i++){
  		bytes[i] = this.data[this.pos + i];
  	}
  	return bytes;
  };

  // read a string from a byte set
  readString(len) {
  	var str = '';
  	for(var i=0; i<len; i++){
  		str += String.fromCharCode(this.readByte());
  	}
  	return str;
  };

  // read a single byte and return an array of bit booleans
  readBitArray() {
  	var arr = [];
  	var bite = this.readByte();
  	for (var i = 7; i >= 0; i--) {
  		arr.push(!!(bite & (1 << i)));
  	}
  	return arr;
  };

  // read an unsigned int with endian option
  readUnsigned(littleEndian) {
  	var a = this.readBytes(2);
  	if(littleEndian){
  		return (a[1] << 8) + a[0];
  	}else{
  		return (a[0] << 8) + a[1];
  	}
  };
}


class DataParser {
  constructor(data) {
  	this.stream = new ByteStream(data);
  	// the final parsed object from the data
  	this.output = {};
  }

  parse(schema) {
  	// the top level schema is just the top level parts array
  	this.parseParts(this.output, schema);
  	return this.output;
  };

  // parse a set of hierarchy parts providing the parent object, and the subschema
  parseParts(obj, schema) {
  	for(var i=0; i<schema.length; i++){
  		var part = schema[i];
  		this.parsePart(obj, part);
  	}
  };

  parsePart(obj, part) {
  	var name = part.label;
  	var value;

  	// make sure the part meets any parse requirements
  	if(part.requires && ! part.requires(this.stream, this.output, obj)){
  		return;
  	}

  	if(part.loop){
  		// create a parse loop over the parts
  		var items = [];
  		while(part.loop(this.stream)){
  			var item = {};
  			this.parseParts(item, part.parts);
  			items.push(item);
  		}
  		obj[name] = items;
  	}else if(part.parts){
  		// process any child parts
  		value = {};
  		this.parseParts(value, part.parts);
  		obj[name] = value;
  	}else if(part.parser){
  		// parse the value using a parser
  		value = part.parser(this.stream, this.output, obj);
  		if(!part.skip){
  			obj[name] = value;
  		}
  	}else if(part.bits){
  		// convert the next byte to a set of bit fields
  		obj[name] = this.parseBits(part.bits);
  	}
  };

  // parse a byte as a bit set (flags and values)
  parseBits(details) {
  	var out = {};
  	var bits = this.stream.readBitArray();
  	for(var key in details){
  		var item = details[key];
  		if(item.length){
  			// convert the bit set to value
  			out[key] = bitsToNum(bits.slice(item.index, item.index + item.length));
  		}else{
  			out[key] = bits[item.index];
  		}
  	}
  	return out;
  };
}

// combine bits to calculate value
function bitsToNum(bitArray) {
  return bitArray.reduce(function(s, n) { return s * 2 + n; }, 0);
}


var Parsers = {
	// read a byte
	readByte: function(){
		return function(stream){
			return stream.readByte();
		};
	},
	// read an array of bytes
	readBytes: function(length){
		return function(stream){
			return stream.readBytes(length);
		};
	},
	// read a string from bytes
	readString: function(length){
		return function(stream){
			return stream.readString(length);
		};
	},
	// read an unsigned int (with endian)
	readUnsigned: function(littleEndian){
		return function(stream){
			return stream.readUnsigned(littleEndian);
		};
	},
	// read an array of byte sets
	readArray: function(size, countFunc){
		return function(stream, obj, parent){
			var count = countFunc(stream, obj, parent);
			var arr = new Array(count);
			for(var i=0; i<count; i++){
				arr[i] = stream.readBytes(size);
			}
			return arr;
		};
	}
};
